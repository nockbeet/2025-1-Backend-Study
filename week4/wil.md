2025-1 고급 백엔드 스터디 week4
================================

* # 2장 B-트리 개요
    * ## 유비쿼터스 B-트리
        * ### 키 개수
            * 키와 자식 오프셋 수를 계산하는 방식
                * 최적의 페이지 크기를 나타내는 자연수 k를 기반으로, 페이지에 k~2k개의 키가 있으며 최소 k + 1에서 최대 2k + 1개 자식 노드를 가리키는 포인터를 저장하는 방식
                    * 루트 페이지는 1~2k개의 키를 포함할 수 있으며 리프가 아닌 모든 페이지는 최대 I + 1개의 키를 포함한다.
                * 각 노드에 최대 N개의 구분 키와  N + 1개의 포인터를 저장하는 방식. N은 키의 개수(리프 노드의 경우 키-값 쌍의 개수)
        * ### B-트리 노드 분할
            * B-트리에 새로운 노드를 삽입하려면 대상 리프를 찾고 삽입할 위치를 결정해야 한다.
                * 탐색 알고리즘을 사용해 리프 노드를 찾고 새 키-값 쌍을 추가하거나, 기존 키 값을 업데이트한다.

            * 리프 노드에 남은 공간이 없는 노드를 오버플로우 상태라고 표현한다.
                * 오버플로우 상태의 노드에 새로운 키를 삽입하려면 노드를 분할해야 한다.
            * 노드 분할 작업 조건
                * 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍 삽입 사용량이 초과되는 경우
                * 리프가 아닌 노드: 노드에 최대 N + 1개의 포인터를 저장할 수 있고 포인터 추가 사용량이 초과되는 경우
            * 노드 분할은 새로운 노드를 할당해 키의 절반을 새로운 노드로 옮기고 첫 번째 키와 포인터를 부모 노드에 추가하는 방식으로 이루어진다. (키의 승급)
                * 분할이 발생한 키를 분할 지점(미드포인트)이라고 부른다.
                * 이 키의 앞 키는 그대로 남겨두고 나머지(리프 노드의 분할일 경우 분할 지점 포함) 키는 새로 생성한 형제 노드로 옮긴다.
                * 부모 노드에 승급키와 포인터를 추가할 공간이 없을 경우, 부모 노드도 분할해야 한다. 이 경우 노드 분할이 루트 노드까지 재귀적으로 전파될 수 있다.
            * 트리에 용량이 부족하면 (루트까지 재귀적으로 분할이 전파된 경우) 루트 노드를 분할해야 한다.
                * 분할 지점의 키를 포함하는 새로운 루트 노드를 생성한다.
                * 기존 루트 노드(기존 키의 절반만 포함)와 생성된 형제 노드는 다음 레벨로 강등되고 트리의 높이가 한 레벨 증가한다.
                * 루트 노드 분할로 인해 새로운 루트 노드를 할당하거나 노드 병합으로 인해 새로운 루트 노드가 형성되면 트리의 높이가 변한다. 반면 리프와 내부 노드 레벨에서는 트리가 수평으로만 확장된다.

            * 노드 분할의 네 가지 단계
                * 새로운 노드를 할당한다.
                * 분할 노드 키의 절반을 새로운 노드로 복사한다.
                * 새로운 키를 알맞은 노드에 삽입한다.
                * 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터를 추가한다.
        
        * ### B-트리 노드 병합
            * 키를 삭제하는 경우 대상 키가 포함된 리프 노드를 찾는다. 리프 노드를 찾았으면 해당 키와 값을 삭제한다.
            * 키를 삭제하다 보면노드에 저장된 값이 너무 적은 경우가 생기는데(언더플로우), 이럴 땐 형제 노드들을 병합해야 한다.
            * 노드 병합 조건
                * 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작거나 같은 경우
                * 리프가 아닌 노드: 노드에 최대 N + 1개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N + 1보다 작거나 같은 경우
            * 노드 병합 단계
                * 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사한다.
                * 부모 노드에서 오른쪽 노드를 가리키는 포인터를 제거한다. 이때, 리프 노드 병합이 아니면 키가 강등된다.
                * 오른쪽 노드를 제거한다.

* # 3장 파일 포맷
    * ## 파일 포맷의 중요성
        * 파일 포맷 설계는 메모리 모델이 비관리형인 프로그래밍 언어로 자료 구조를 설계하는 것과 유사하다.
            * 데이터 블록을 할당하고 고정 크기의 기본형과 자료 구조를 사용해 원하는 모양대로 블록을 잘라서 사용한다.
            * 큰 메모리 청크 또는 가변 길이의 자료 구조는 포인터를 사용해 참조한다.
        * 메모리 모델이 비관리형인 프로그래밍 언어는 연속된 메모리 세그먼트의 존재 여부, 메모리 단편화 여부, 메모리 해제 이후의 상황 등을 신경 쓰지 않고 필요하면 언제든지 메모리를 추가 할당한다.
            * 디스크 사용 시 가비지 컬렉션과 단편화를 모두 직접 관리해야 한다.
        * 데이터를 메인 메모리에 저장하면 메모리 레이아웃과 관련한 대부분의 문제가 발생하지 않고나 서드파티 라이브러리를 사용해 해결할 수 있다.
            * 가변 길이 필드나 크기를 초과한 데이터를 처리하기 쉽다.
            * 메모리 할당과 포인터를 사용할 수 있으므로 데이터를 어떤 특별한 레이아웃으로 저장하지 않아도 된다.
        
    * ## 바이너리 인코딩
        * 데이터를 효율적으로 디스크에 저장하려면 컴팩트하고 직렬화와 역직렬화가 쉬운 포맷으로 인코딩해야 한다.
        * 디스크에 저장된 데이터를 malloc과 free와 같은 원시 함수로 제어할 수 없고, 오직 read와 write 함수만을 사용할 수 있기 때문에 접근 방식이 다르고 이에 맞는 형식으로 데이터를 저장해야 한다.

        * ### 기본형
            * 키와 값은 integer, date, string 등의 지정된 자료형이 있고, 바이너리 형식으로 표현할 수 있다.
            * 대부분의 숫자형은 고정 길이 자료형이다.
                * 멀티바이트 숫자형을 사용할 때 인코딩과 디코딩은 모두 같은 바이트 순서를 사용해야 한다.
                * 엔디언(endianess)은 바이트 배열 순서를 정의한다.
                    * `빅 엔디언(big endian)` : 최상위 바이트(MSB, Most-Significant Byte)부터 시작해서 내림차순으로 저장한다. 즉, MSB를 가장 낮은 주소에 저장한다.
                    * `리틀 엔디언(little endian)` : 최하위 바이트(LSB, Least-Significant Byte)부터 높은 자리 바이트까지 오름차순으로 저장한다.
            * 레코드는 숫자, 문자열, 불리언 같은 기본형과 이들의 조합으로 구성된다.
                * 레코드는 바이트 시퀀스 형태로 네트워크를 통해 전송되고 디스크에 저장한다.
                * 전송 및 쓰기 전 `직렬화`(serialize, 해석할 수 있는 바이트 시퀀스로 변환)하고 수신 및 읽기 전에 `역직렬화`(deserialize, 바이트 시퀀스를 원래 레코드 형태로 변환)해야 한다.
            
            * 숫자형 : byte형은 8비트, short는 2바이트(16비트), int는 4바이트(32비트), long은 8바이트(64비트)이다.
            * 부동소수점 : 부호(sign)와 가수(fraction), 지수(exponent)로 구성된다(float와 double).
                * IEEE Standard for Binary Floating-Point Arithmetic(`IEEE 754`)은 부동소수점을 표현하는 표준이다.
                * double형은 배정도(double precision)을 표현한다.
        * ### 문자열과 가변 길이 데이터
            * 문자열과 가변 길이 자료형(고정 길이 데이터 배열)은 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 size 바이트 크기의 실제 데이터로 구성된다. 이런 형식을 `UCSD 문자열` 또는 `파스칼 문자열`이라고 부른다.

            * 파스칼 문자열의 대안은 널 종단(null terminated) 문자열이다. 바이트 단위로 문자열 끝 기호에 도달할 때까지 읽는다.

        * ### 비트 묶음형 데이터: 불리언, 열거형, 플래그
            * 불리언 자료형은 단일 바이트 또는 true와 false를 1과 0으로 인코딩한 값을 표현한다.
                * 불리언은 두 개의 값만 표현할 수 있으므로 바이트 전체를 사용하는 것은 낭비다.
                * 8개의 불리언 값이 각 1비트씩 사용하도록 묶어 쓰기도 한다.(묶음형 불리언)
                * 비트의 값이 1이면 설정 상태, 0이면 미설정 또는 빈 상태라고 표현한다.
            * Enum은 열거형(enumerated type)의 줄임말이며 숫자를 표현한다.
                * 바이너리 포맷과 통신 프로토콜에서 주로 사용된다.
                * 가짓수가 적고 자주 반복해서 나오는 값을 표현할 때 사용한다.
            * 플래그는 묶음형 불리언과 열거형의 조합으로 이루어진다.
                * 플래그는 상호배타적이지 않은 불리언 값들을 표현할 수 있다.
                * 페이지의 값 보유 여부와 특정 값 크기의 고정 또는 가변 여부, 특정 노드의 페이지에 오버플로우 발생 여부 등을 나타낼 때 사용된다.
                * 묶음형 불리언과 마찬가지로, 비트마스크와 비트 연산자를 사용해 값을 묶어서 표현할 수 있다.