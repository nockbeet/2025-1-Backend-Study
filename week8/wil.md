2025-1 고급 백엔드 스터디 week8
================================

* # 5장 트랜잭션 처리와 복구
    * DBMS에서 트랜잭션이란 하나의 논리적 작업 단위를 의미한다.
        * 여러 작업을 한 단계로 표현하는 방법이다.
    
    * 모든 데이터베이스 트랜잭션은 원자성과 일관성, 격리성, 지속성을 보장한다.
        * `원자성(Atomicity)` : 트랜잭션을 더 작은 단위로 나눌 수 없고, 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패해야 한다.
        * `일관성(Consistency)` : 트랜잭션은 참조 무결성 등의 제약 조건을 위반하지 않고 데이터베이스를 하나의 유효한 상태에서 또 다른 유효한 상태로 변경한다.
        * `격리성(Isolation)` : 동시에 수행되는 여러 트랜잭션은 다른 트랜잭션이 존재하지 않는 것처럼, 서로 간섭 없이 수행되어야 한다.
            * 많은 데이터베이스는 성능상의 이유로 약한 격리 수준을 사용한다.
            * 동시성 제어 방식에 따라 트랜잭션의 변경 내용 중 일부가 동시 수행 중인 다른 트랜잭션에 노출될 수도 있고 노출되지 않을 수도 있다.
        * `지속성(Durability)` : 트랜잭션 커밋 후 디스크에 저장된 데이터베이스의 상태는 시스템이 중단되거나 시스템 장애가 발생해도 그대로 유지되어야 한다.

     * 트랜잭션을 수행하기 위해선 여러 컴포넌트가 필요하다.
        * 트랜잭션 매니저는 트랜잭션의 세부 단계를 제어, 관리 및 스케줄링하는 컴포넌트다.

        * 잠금 매니저는 리소스에 대한 동시 접근을 제어하고 데이터 무결성을 보장한다.

        * 페이지 캐시는 영구 저장소(디스크)와 스토리지 엔진 사이에서 중개자 역할을 한다.

        * 로그 매니저는 영구 저장소와 동기화되지 않은 페이지 캐시의 내용이 손실되지 않도록 작업 히스토리(로그)를 저장한다.
    
    * ## 버퍼 관리
        * 대부분의 데이터베이스는 상대적으로 속도가 느린 영구 저장소(디스크)와 빠른 메모리로 구성된 메모리 계층 구조로 되어 있다.
            * 영구 저장소 접근 횟수를 줄이기 위해 페이지를 메모리에 캐시하고 스토리지 계층에서 캐시된 페이지를 재요청하면 캐시에서 반환한다.
        
        * `가상 디스크(페이지 캐시, 버퍼 풀 방식)` 방식 : 다른 프로세스가 저장된 같은 페이지를 변경하지 않았다면 메모리에 캐시된 페이지를 재사용할 수 있다.
            * 가상 디스크 읽기 작업은 요청된 페이지가 메모리에 없을 경우에만 물리적 저장소에 접근한다.
            * 페이지 캐시는 디스크에서 읽은 페이지를 메모리에 캐시한다. 시스템 장애가 발생하거나 시스템이 비정상적으로 종료되면 캐시된 페이지는 사라진다.
        
        * 아직 캐시되지 않은 페이지를 디스크에서 메모리로 복사하는 작업을 `페이징`이라고 한다.
            * 아직 디스크로 플러시되지 않은 변경된 페이지를 `더티 페이지`라고 표현한다.
        
        * 페이지 캐시의 주요 기능
            * 페이지 내용을 메모리에 캐시한다.
            * 디스크에  페이지에 대한 변경 사항을 함께 버퍼링하고 캐시된 페이지에 반영한다.
            * 캐시되지 않은 데이터가 요청된 경우 메모리에 공간이 충분하다면 페이징하고 캐시된 버전을 반환한다.
            * 캐시된 페이지가 요청된 경우 메모리에서 반환한다.
            * 메모리에 새로운 페이지를 추가할 공간이 없을 경우 일부 페이지를 만료시키고 페이지로 플러시한다.
        
        * ### 캐싱
            * 페이지를 캐시하면 알고리즘을 수정하거나 객체를 메모리에 실체화하지 않고 트리의 일부를 메모리에 저장할 수 있다. 디스크에 접근하는 대신 패이지 캐시를 요청하는 방식이다.

            * 스토리지 엔진이 특정 페이지를 요청하면 캐시된 버전이 있는지 확인하고, 만약 있을 경우 이를 반환한다.
                * 없을 경우엔 논리적 페이지 주소 또는 페이지 번호를 물리적 주소로 변환해 해당 페이지를 메모리에 복사하고 반환한다. 이때 해당 페이지가 저장된 버퍼는 `참조 상태`라고 표현한다.
                * 작업이 끝나면 스토리지 엔진은 해당 페이지를 페이지 캐시에 반환 또는 참조 해제해야 한다.
            * 페이지가 변경된 경우 페이지에 `더티 플래그`를 설정한다.
                * 더티 플래그는 해당 페이지가 디스크와 동기화되지 않았고 지속성을 위해 디스크로 플러시되어야 한다는 것을 의미한다.
        
        * ### 캐시 만료
            * 페이지 캐시의 크기는 한정적이므로, 새로운 페이지를 저장하기 위해 오래된 페이지는 제거해야 한다.
                * 페이지는 동기화되었고(이미 플러시되거나, 수정되지 않음) 고정 또는 참조 상태가 아니라면 바로 제거될 수 있다.
                * 더티 페이지는 제거되기 전에 먼저 플러시해야 한다.
                * 참조 상태의 페이지는 사용이 끝나기 전까지는 제거될 수 없다.
            
            * 캐싱에 존재하는 trade-off
                * 디스크 접근 횟수를 줄이기 위해 플러시 시점을 늦춘다.
                * 페이지를 우선적으로 플러시해 빠르게 캐시에서 제거한다.
                * 제거할 페이지를 선택하고 최적의 순서로 플러시한다.
                * 캐시 크기를 메모리 범위 내로 유지한다.
                * 기본 저장소에 저장되지 않은 데이터는 손실되지 않아야 한다.

        * ### 페이지 고정 
            * 페이지를 캐시에 가둬 두는 것을 고정한다고 표현한다.
                * 고정된 페이지는 메모리에 더 오랜 시간 동안 유지되므로 디스크 접근 횟수가 줄어들고 성능에 도움이 된다.
            
        * ### 페이지 교체 알고리즘
            * 캐시된 페이지는 `만료 정책(eviction policy, 페이지 교체 알고리즘)`에 따라 캐시에서 제거된다.
                * 캐시 만료 정책은 다시 요청될 확률이 가장 낮은 페이지를 만료시키고 해당 위치에 새로운 페이지를 페이징한다.
            
            * #### FIFO
                * 선입선출(First In First Out) 방식의 페이지 교체 알고리즘이다.
                * 페이지 ID를 삽입 순서대로 큐의 끝에 추가한다.
                * 페이지 캐시에 공간이 부족할 경우 큐의 헤드에 저장된 페이지 ID가 가리키는 가장 오래된 페이지를 만료시킨다.
                * 페이지의 접근 순서를 고려하지 않는 방식이다.
            
            * #### LRU
                * FIFO를 확장한 방식이다.
                    * FIFO와 같이 삽입 순서대로 큐에 추가하지만, 페이지가 재요청되면 처음 페이징된 것처럼 다시 큐의 끝에 추가한다.
                * 페이지를 요청할 때마다 페이지에 대한 참조와 노드를 갱신해야 하므로, 동시 접근 환경에서는 매우 비효율적일 수 있다.
            
            * #### CLOCK 알고리즘
                * 캐시 친화적이고 동시성을 지원한다.
                * CLOCL-sweep 알고리즘은 페이지에 대한 참조와 접근 여부를 나타내는 비트를 `원형 버퍼`에 저장한다.
                    * CLOCK-sweep 알고리즘은 원형 버퍼를 순회하면서 접근 비트를 확인한다.
                * 원형 버퍼의 장점은 클럭 포인터와 페이지를 `비교 후 스왑(compare-and-swap)` 방식으로 쉽게 수정할 수 있고 추가적인 잠금 메커니즘이 필요하지 않다는 것이다.
            
            * #### LFU
                * 페이지가 참조된 횟수를 기반으로 제거할 페이지를 선택하는 방법으로, 요청 빈도가 가장 낮은 페이지를 제거한다.