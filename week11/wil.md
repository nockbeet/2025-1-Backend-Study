2025-1 고급 백엔드 스터디 week11
================================

* # 6장 B-트리의 변형
    * B-트리를 효율적으로 구현하는 방법 및 이를 기반으로 구현된 트리
        * `쓰기 시 복사형(copy-on-write) B-트리` : B-트리와 유사한 구조이지만 노드를 수정할 수 없고 인플레이스 업데이트를 지원하지 않는다.
        * `지연형(lazy) B-트리` : 동일한 노드에 대한 연속된 쓰기 작업의 I/O 요청 횟수를 줄이기 위해 수정 내용을 버퍼에 저장한다.
        * `FD-트리` : LSM 트리와 유사한 버퍼 메커니즘을 사용한다. 작은 크기의 B-트리를 버퍼로 사용하고 버퍼가 가득 차면 그 내용을 불변 형태로 기록한다. 수정 사항은 상위 레벨에서 하위 레벨로 전파된다.
        * `Bw-트리` : B-트리 노드를 추가 전용 방식으로 기록되는 여러 작은 그룹으로 나눈다. 여러 노드에 대한 쓰기 작업을 배치 단위로 처리해 비용을 낮춘다.
        * `캐시 비인지형(cache-oblivious) B-트리` : 디스크 기반 자료 구조를 인메모리 자료 구조처럼 사용한다.

    * ## 쓰기 시 복사
        * 일부 데이터베이스는 동시 수행 작업의 데이터 무결성 보장을 위해 복잡한 래치 메커니즘 대신 `쓰기 시 복사 방식`을 사용한다.
            * 페이지 수정 전에 내용을 복사해 원본 대신 복사본을 수정한다.
            
        * 라이터와 동시 수행 중인 리더는 과거 버전의 트리를 읽을 수 있으나, 라이터가 작업 중인 수정된 페이지에 접근해야 하는 라이터는 먼저 수행 중인 쓰기 작업이 모두 완료될 때까지 대기해야 한다.
            * 새로운 페이지 계층이 생성되면 최상단 페이지를 가리키는 포인터를 업데이트한다.
            
        * 이 방식의 단점은 더 많은 메모리가 필요하다는 점이다.
            * 페이지 전체를 복사하기 때문에 프로세서 사용량도 증가한다.
            
        * 쓰기 시 복사의 장점은 한 번 쓴 페이지는 수정할 수 없고 접근하는 데 래치가 필요 없기 때문에 리더를 위해 동기화하지 않아도 된다는 점이다.
            * 쓰기 작업은 복사본에 대해 수행돼 리더는 라이터를 블록하지 않는다.
            * 모든 수정 작업이 완료됐을 때 최상단 포인터를 갱신하기 때문에 어떤 작업도 불완전한 상태의 페이지에 접근할 수 없고 시스템 장애는 손상된 페이지를 남기지 않는다.
            
        * ### 쓰기 시 복사 방식 구현: LMDB
            * `LMDB(Lightning Memory-Mapped Database)`는 쓰기 시 복사 방식을 사용하는 데이터베이스 엔진이다.
                * LMDB는 구조와 설계상 페이지 캐시와 선행기록 로그, 체크포인트, 컴팩션을 사용하지 않는다.
                
            * LMDB는 단일 레벨 구조의 데이터베이스이다.
                * 애플리케이션 레벨의 캐싱은 하지 않고 읽기와 쓰기 작업이 메모리 맵에 바로 접근한다. 따라서 페이지는 구체화하지 않아도 되며 데이터를 중간 버퍼로 복사하지 않고 메모리 맵에서 바로 읽을 수 있다.
                * 업데이트 시 루트에서 리프 노드까지의 경로의 모든 노드를 복사한다.
                    * 업데이트가 전파되는 노드는 수정하고 나머지는 그대로 유지한다.
            
            * LMDB에는 최신 버전과 변경 사항이 커밋될 버전, 두 개의 버전의 루트 노드가 있다.
    
    * ## 노드 업데이트 추상화
        * 메모리에 저장된 노드에 접근하는 여러 방법이 있다. 캐시된 버전에 바로 접근하는 방법과 기반 언어로 인메모리 객체를 생성하는 방법, 래퍼(wrapper) 객체를 사용하는 방법이 있다.

        * 메모리 모델이 없는 언어는 B-트리 노드에 저장된 원시 이진 데이터를 해석하고 네이티브 포인터를 사용해 제어할 수 있다.
            * 노드는 포인터와 런타임 형변환을 통해 원시 이진 데이터를 제어하는 자료 구조라고 볼 수 있다.
        
        * B-트리 노드를 객체 또는 기반 언어 고유의 자료 구조로 구체화하는 방법
            * 이 자료 구조는 삽입 및 업데이트, 삭제 시 사용하고, 플러시 작업은 변경 사항을 메모리에 저장된 페이지에 반영한 뒤에 디스크로 플러시한다.
            * 이 방식에서 원시 페이지 수정은 중간 객체에 대한 접근과 별개로 수행되므로 동시 접근이 쉽다.
                * 하지만 메모리에 두 개의 버전(로우 이진 데이터와 언어 고유 자료 구조)의 페이지를 저장하기 때문에 메모리 오버헤드가 발생한다.
        
        * 변경 사항을 즉시 B-트리에 구체화하는 래퍼 객체를 통해 노드가 복사된 버퍼에서 읽는 방법도 있다.
            * 래퍼 객체는 버퍼에 변경 사항을 반영한다.

        * 디스크에 저장된 페이지와 캐시된 버전, 인메모리 버전을 모두 따로 관리하면 각각 다른 라이프 사이클을 가질 수 있다.
    
    * ## 지연형 B-트리
        * 일부 B-트리 알고리즘은 더 가볍고 동시성 지원 및 업데이트가 쉬운 인메모리 자료 구조를 사용해 변경 사항을 버퍼하고 동기화를 지연해 업데이트 비용을 낮춘다.
        
        * ### 와이어드타이거
            * MomgoDB의 가본 스토리지 엔진인 와이어드타이거는 로우 스토어(row store) B-트리를 인메모리와 디스크의 페이지에 각각 다른 형식으로 저장한다.
            
            * 와이어드타이거의 페이지와 B-트리 구조
                * 클린 페이지는 디스크 페이지 이미지에서 생성된 인덱스만으로 구성된다.
                * 변경 사항은 업데이트 버퍼에 먼저 저장한다.
            * 업데이트 버퍼는 읽기 작업 시 점근된다.
                * 버퍼된 내용과 원본 디스크 페이지를 합쳐서 가장 최신 데이터를 반환한다.
                * 페이지를 플러시하면 업데이트 버퍼의 내용과 페이지 내용을 합치고 디스크에 저장된 기존 페이지를 덮어쓴다. 만약 합친 페이지가 허용된 최대 크기보다 크면 여러 페이지로 분할한다.
                * 업데이트 버퍼는 검색트리와 복잡도는 유사하지만 더 나은 동시성을 지원하는 `스킵리스트(skiplist)`를 기반으로 한다.

            * 와이어드타이거의 장점은 페이지 업데이트와 구조 변경(분할 및 병합)은 백그라운드 스레드가 처리하므로 읽기와 쓰기 작업은 다른 스레드가 완료될 때까지 기다릴 필요가 없다는 것이다.

        * ### 지연 적응형 트리
            * `지연 적응형(Lazy_Adaptive, LA) 트리`는 각 노드마다 업데이트 버퍼를 유지하지 않고, 노드를 서브트리 단위로 그룹화하고 각 서브트리별로 배치 작업을 저장하는 업데이트 버퍼를 사용하는 방법이다.
                * 업데이트 버퍼에는 해당 서브트리의 최상단 노드와 자식 노드에 대해 수행된 모든 작업 내용을 저장한다.
                * 새로운 데이터 레코드를 삽입할 때 값을 우선 루트 노드의 업데이트 버퍼에 저장한다. 버퍼가 가득 차면 변경 사항을 하위 레벨의 버퍼로 복사 및 이동해 공간을 확보한다.
                    * 하위 레벨 버퍼에 공간이 부족할 경우 리프 노드까지 이 과정을 반복한다.
            
            * 버퍼는 계층 종속적이며 계단식으로 전달된다. 모든 변경 사항은 상위 레벨 버퍼에서 하위 레벨 버퍼로 전파된다.
                * 업데이트가 리프 레벨에 도달하면 삽입과 업데이트, 삭제 작업을 배치 단위로 수행하게 되며, 모든 내용 수정 및 구조 변경 작업을 한 번에 반영한다.
                * 특정 페이지에 대한 연속적인 업데이트 작업을 개별로 수행하지 않고 한 번에 업데이트한다.
                * 결과적으로 디스크 요청 횟수가 줄어들고 상위 레벨로 전파되는 분할 및 병합 작업도 배치 단위로 적용되어 구조 변경 횟수가 줄어든다.
    
    * ## FD-트리
        * 버퍼링은 여러 소규모 랜덤 쓰기를 피하고 더 큰 규모로 쓰기 작업을 수행하게 해 준다.

        * B-트리 유지관리 작업에서는 리프 노드 수정과 부모 레벨로 전파되는 분할 및 병합 등의 과정에서 많은 랜덤 쓰기가 발생한다. 랜덤 쓰기와 노드 업데이트 횟수를 낮출 수 있는 방법이 필요하다.
            * 개별 노드나 노드 그룹에 보조 버퍼를 사용해 변경 사항을 버퍼링하는 방법이 있다.
            * 다른 방법으로는 추가 전용 스토리지와 병합 프로세스를 사용해 여러 노드에 대한 업데이트 작업을 그룹화하는 방법도 있다.
                * 이 방식은 LSM 트리에서 사용하는 방식이다.
                * 쓰기 작업 시 대상 리프 노드를 찾을 필요 없이 작업 내용을 추가하기만 하면 된다. `FD-트리(FD-Tree, Flash Disk Tree)`는 이 방식으로 데이터를 인덱싱한다.
        
        * FD-트리는 작은 가변 헤드 트리와 여러 개의 정렬된 불변 배열로 구성된다.
            * 랜덤 쓰기를 하는 위치가 변경 사항을 버퍼하는 작은 B-트리(헤드 트리)로 줄어든다.
            * 헤드 트리가 가득 차면 저장된 내용을 불변 배열로 옮긴다.
            * 새로운 배열의 크기가 일정량보다 크면 다음 레벨의 배열과 합친다. 데이터 레코드는 상위 레벨에서 하위 레벨로 복사된다.
        
        * ### 부분적 캐스케이딩
            * FD-트리는 `부분적 캐스케이딩(fractional cascading)`을 사용해 레벨 간 포인터를 유지한다.
                * 이 방식을 사용해 정렬된 배열에서 특정 아이템을 찾는 비용을 줄일 수 있다.
            
            * 갭(상위 레벨에서 참조하는 포인터가 없는 그룹)을 최소화하기 위해 인근 레벨의 배열을 브리지를 통해 연결하고 레벨 사이 지름길을 만든다.
                * 브리지는 상위 레벨에 존재하지 않는 요소를 하위 레벨에서 끌어올리고 하위 레벨에서의 위치를 가리키는 포인터다.
            
            * 상위 레벨 배열의 모든 원소를 다음 레벨에서 가장 근접한 요소와 매핑하면 포인터 사용과 유지보수 비용이 급격하게 들어난다.
                * 상위 레벨에 있는 요소만 매핑하면 요소 사이의 갭이 많아진다.
                    * 하위 레벨 배열의 모든 N번째 아이템을 상위 레벨로 끌어올리면 이 문제를 해결할 수 있다.
            
            * 모든 배열에서 특정 원소를 찾으려면 우선 최상위 레벨에서 이진 탐색을 수행한다.
                * 브리지를 따라 레벨을 내려갈수록 더 근접한 값의 위치로 이동하기 때문에 탐색 공간이 급격히 줄어든다. 따라서 여러 정렬된 리스트를 연결해 탐색 비용을 줄일 수 있다.
        
        * ### 로그 배열
            * FD-트리는 부분적 캐스케이딩과 로그 단위로 증가하는 배열을 결합해 사용한다. 이 배열은 이전 레벨의 배열과 현재 배열을 합친 정렬된 불변 배열이면 크기가 k의 배수로 증가한다.

            * 정렬된 배열의 모든 요소에 접근할 수 있도록 FD-트리는 개선된 버전의 부분적 캐스케이딩을 사용한다.
                * 하위 레벨 페이지의 헤드 요소를 상위 레벨의 포인터로 끌어올린다.
                * 이 포인터를 사용해 상위 레벨에서 검색 대상 키에 더 가까운 값을 찾을 수 있어, 하위 레벨 탐색 비용이 줄어든다.
            
            * FD-트리는 페이지를 인플레이스 업데이트하지 않기 때문에 같은 키가 여러 레벨에 존재할 수 있다.
                * FD-트리는 삭제된 키에는 삭제됐음을 나타내는 `툼스톤(tombstone)`을 삽입한다.
                * 하위 레벨에  조냊하는 같은 키의 레코드도 모두 삭제되어야 한다.
                * 툼스톤이 최하위 레벨까지 전파되면 더 이상 남은 값이 없기 때문에 모두 삭제해도 된다.
