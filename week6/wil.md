2025-1 고급 백엔드 스터디 week6
================================

* # 4장 B-트리 구현
    * ## 페이지 헤더
        * 페이지 헤더에는 탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보를 저장한다.
            * 일반적으로 페이지 내용을 나타내는 플래그, 레이아웃, 셀 개수, 빈 공간을 가리키는 하한 및 상한 오프셋 같은 유용한 메타데이터를 저장한다.

        * ### 매직 넘버
            * 매직 넘버는 상수 값을 포함하는 멀티바이트 블록이며, 페이지의 종류와 버전 같은 정보를 포함한다.
            * 매직 넘버는 검증과 상태 체크에 사용된다.
        
        * ### 형제 링크
            * 좌우에 있는 형제 페이지를 가리키도록 순방향 링크와 역방향 링크를 저장하는 방식으로 트리를 구현할 수 있다.
                * 부모 노드로 거슬러 올라가지 않고 이웃 노드를 바로 참조하는 방식이다.
                * 분할 및 병합 시 이웃 오프셋까지 갱신해야 하므로 약간 더 복잡한 방식이다.
            * 형제 링크를 저장하는 방식의 단점은 노드 분할 및 병합 시 링크를 업데이트해야 한다는 것이다.
                * 분할 및 병합 대상 노드뿐만 아니라 형제 노드까지 업데이트하기 위해 추가적으로 잠금이 필요할 수 있다.
        
        * ### 가장 오른쪽 포인터
            * B-트리의 구분 키의 주 역할은 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것이다. 따라서 자식 페이지를 가리키는 포인터가 키보다 반드시 하나 더 있다.
                * 각 구분 키에는 자식 포인터가 있고, 마지막 포인터는 어떤 키와도 연관되지 않고 따로 저장된다.
        
        * ### 하이 키
            * 각 트리 노드의 가장 오른쪽 포인터와 노드의 하이 키(high key)를 함께 저장하는 방법을 사용할 수 있다. 하이 키는 현재 노드의 서브트리에 저장된 가장 큰 키를 나타낸다. 이런 형식의 트리를 B<sup>link</sup>-트리라고 한다.
                * B<sup>link</sup>-트리는 각 노드에 K<sub>N+1</sub> 키를 하나씩 더 추가로 저장한다. 이 키는 포인터 P<sub>N</sub>이 가리키는 서브트리에서 가장 큰 키를 나타낸다. 즉 이 키의 값이 해당 서브트리에 저장할 수 있는 최댓값이 된다.
                * 하이 키를 저장하는 트리는 각 노드에 저장된 키와 포인터의 개수가 같고, 모든 셀에는 키-포인터 쌍이 존재한다.
        
        * ### 오버플로우 페이지
            * 노드 크기와 트리 팬아웃은 고정된 값으로, 동적으로 변하지 않는다.

            * B-트리 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야 한다.
            
            * 여러 페이지를 연결하면 데이터를 다른 연속된 공간으로 복사하지 않고 가변 크기 노드를 구현할 수 있다.

            * 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장한다.
                * 고정 크기는 노드 크기를 팬아웃으로 나눈 값이다.
                * 페이지에 최소 `max_payload_byte` 바이트만큼의 공간이 항상 남아 있기 때문에 페이지에 공간이 부족한 상황은 발생하지 않는다.
            
            * 삽입된 데이터가 max_payload_size보다 크다면 해당 노드에 연결된 오버플로우 페이지가 있는지 확인해야 한다.
                * 오버플로우 페이지가 존재하고 공간이 충분히 남아 있다면 나머지 바이트를 해당 페이지에 저장한다. 없다면 새로운 오버플로우 페이지를 할당한다.
    
    * ## 이진 검색
        * 이진 검색은 데이터가 정렬된 경우에만 유효하고 정렬되지 않은 키로는 검색이 불가능하다.
        * 삽입 위치는 검색 키보다 첫 번째로 큰 값의 위치다. 삽입 시에는 삽입 위치 이후의 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다.

        * ### 간접 포인터를 사용한 이진 검색
            * B-트리 페이지의 셀은 삽입 순서대로 저장되며 셀 오프셋만 논리적 순서를 유지한다.
            * 페이지 셀의 이진 검색은 우선 중간 셀 오프셋을 선택하고 해당 위치의 키와 검색 키를 비교해 왼쪽과 오른쪽 중 진행 방향을 결정한다. 이 과정을 대상 키 또는 삽입 위치를 찾을 때까지 재귀적으로 반복한다.
    
    * ## 분할과 병합
        * 일부 B-트리에서는 노드에 부모 노드를 가리키는 포인터를 저장한다.
            * 하위 레벨의 페이지는 항상 바로 위 레벨을 통해 참조되기 때문에 부모 노드에 대한 정보는 디스크에 저장하지 않아도 된다.
        
        * 형제 포인터와 마찬가지로, 부모 포인터도 부모가 변경되면 알맞게 갱신해야 한다.
            * 부모 노드의 분할과 병합, 재배치 과정에서 페이지 ID를 포함하는 구분 키가 한 노드에서 다른 노드로 이동했을 때 갱신해줘야 한다.
        
        * ### 탐색 경로
            * B-트리의 구조를 변경하기 위해서는 루트에서 리프 노드 또는 삽입 지점까지 트리를 순회해야 한다.
                * 리프 노드에 도달하기 전에는 분할이나 병합 발생 여부를 알 수 없으므로 탐색 경로를 저장해야 한다.

            * 탐색 경로는 루트부터 방문한 모든 노드에 대한 정보를 포함한다. 이런 정보는 분할 또는 병합이 상위 레벨로 전파될 때 노드를 거슬러 올라가는 데 쓴다.
                * 노드가 분할되거나 병합되는 경우, 저장된 탐색 경로를 이용해 부모 노드로 승급된 키의 삽입 지점을 찾고 필요하다면 더 상위 레벨의 노드까지 차례대로 방문하면서 구조를 변경한다.
                * 경로를 저장한 스택은 메모리에 유지된다.