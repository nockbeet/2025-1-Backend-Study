2025-1 고급 백엔드 스터디 week9
================================

* # 5장 트랜잭션 처리와 복구
    * ## 복구
        * 데이터베이스 시스템들은 각자 다른 안정성과 신뢰성 문제를 내재한 여러 하드웨어와 소프트웨어 계층으로 구성된다.
            * 이에 따라 데이터베이스 시스템 자체와 기반 소프트웨어, 하드웨어 컴포넌트에 장애가 발생할 수 있다.

        * `선행 기록 로그(WAL, 커밋 로그)`는 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용 보조 자료 구조이다.
            * 페이지 캐시는 페이지에 대한 변경 사항을 메모리에 버퍼링한다.
            * 캐시된 내용이 디스크로 플러시될 때까지 관련 작업 이력의 유일한 디스크 복사본은 WAL이다.
        
        * WAL의 주요 기능
            * 디스크에 저장된 페이지에 대한 변경 사항을 페이지 캐시에 버퍼링하는 동시에 데이터베이스 시스템 맥락에서의 지속성을 보장한다.
            * 캐시된 페이지가 디스크와 동기화될 때까지 작업 이력을 디스크에 저장한다. 데이터베이스의 상태를 변경하는 모든 작업을 실제 페이지에 적용하기 전에 먼저 디스크에 로깅한다.
            * 장애 발생 시 로그를 기반으로 마지막 메모리 상태를 구성한다.
        
        * WAL은 트랜잭션 처리에 중요한 역할을 한다.
            * WAL은 데이터가 영구 저장소에 저장되도록 보장하고 로그를 재수행해서 커밋되지 않은 트랜잭션을 완료하거나 장애가 발생하기 전의 상태로 되돌릴 수 있다.

        * ### 로그의 시맨틱
            * WAL은 추가 전용 자료 구조이며, 작성된 데이터는 불변하므로 모든 쓰기 작업은 순차적이다.
            * WAL은 여러 로그 레코드로 구성된다. 모든 레코드에는 단조 증가하는 `고유 로그 시퀀스 번호(LSN, Log Sequence Number)`가 있다.
                * 일반적으로 LSN은 내부 카운터 값 또는 타임스탬프 값이다.
                * 로그 레코드의 크기는 디스크 블록의 크기보다 작을 수 있으므로 로그 버퍼에 임시 저장하고 포스 작업 시 디스크에 플러시한다.
                    * 포스 작업은 로그 버퍼가 가득 차면 수행되거나 트랜잭션 매니저 또는 페이지 캐시가 직접 요청할 수도 있다.
            
            * WAL은 작업 로그 레코드 외에도 트랜잭션 완료 여부를 나타내는 레코드를 저장한다.
                * 트랜잭션의 커밋 레코드의 LSN이 플러시되기 전까지는 해당 트랜잭션은 커밋된 것으로 간주할 수 없다.
            
            * 일부 시스템은 트랜잭션 롤백 또는 복구 중 장애가 발생해도 시스템이 계속해서 정상 작동할 수 있도록 `보상 로그 레코드(CLR, Compensation Log Record)`를 로그에 저장하고 undo 작업 시 사용한다.

            * 일반적으로 WAL은 체크포인트에 도달하면 이전 로그를 정리하는 인터페이스를 통해 기본 저장소와 동기화한다.

            * `체크포인트`는 해당 시점 이전의 모든 레코드가 플러시됐고 더 이상 필요하지 않다는 것을 로그에 명시하는 수단이다.
                * 모든 더티 페이지를 강제로 디스크로 플러시해 기본 저장소와 완전히 동기화하는 작업을 싱크 체크포인트라고 한다.
            
            * 모든 데이터를 한번에 디스크로 플러시하면 체크포인트 작업이 완료되기 전까지 다른 작업을 중단해야 하는 비효율적인 상황이 발생하는데, 이를 방지하기 위해 대부분의 데이터베이스 시스템은 `퍼지 체크포인트`를 사용한다.
                * 퍼지 체크포인트는 begin_checkpoint라는 특별한 로그 레코드로 시작해 더티 페이지에 대한 정보와 트랜잭션 테이블의 내용을 저장한 end_checkpoint로 끝난다.
                * 로그 레코드에 명시된 모든 페이지가 플러시될 때까지 해당 체크포인트는 미완료 상태이다.
                * 페이지는 비동기적으로 플러시되면, 이 작업이 끝나면 last_checkpoint 레코드를 begin_checkpoint의 LSN으로 업데이트한다.
        
        * ### 작업 로그 대 데이터 로그
            * 모든 상태 변화는 이전 상태와 이후 상태의 조합으로 나타낼 수 있고, 그에 대응되는 `redo` 작업과 `undo` 작업으로 나타낼 수 있다.
                * 이전 상태에 redo 작업을 수행하면 이후 상태가 된다. 반대로 이후 상태에 undo 작업을 수행하면 이전 상태가 된다.

            * `물리적 로그(전체 페이지 상태 또는 바이트별 변경 사항)` 또는 `논리적 로그( 현재 상태에 대해 수행해야 하는 작업)`를 사용해 레코드와 페이지의 상태를 한 상태에서 다른 상태로 되돌리거나 재구성할 수 있다.
                * 물리적 로그에는 수행 전후의 상태를 모두 저장하기 때문에 로깅 대상 작업에 의해 영향을 받은 모든 페이지를 참조해야 한다.
                * 논리적 로그에는 페이지에 수행해야 하는 작업과 해당 작업의 undo 작업을 저장한다.
            * 대부분의 데이터베이스 시스템은 물리적 로그와 논리적 로그를 모두 사용한다. undo 작업에는 논리적 로그를 사용하고 redo 작업에는 물리적 로그를  사용한다.
        
        * ### 스틸과 포스 정책
            * DBMS는 `스틸/노스틸(steal/no-steal)` 정책과 `포스/노포스(force/no-force)` 정책을 기반으로 메모리에 캐시된 변경 사항을 디스크로 플러시하는 시점을 결정한다.

                * 스틸 정책은 트랜잭션이 수행한 페이지를 커밋하기도 전에 플러시하는 것을 허용한다. 노스틸 정책은 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않는다.
                    * 더티 페이지를 스틸한다는 것은 메모리에 캐시된 데이터를 디스크로 플러시하고 디스크에서 다른 페이지를 페이징한다는 것이다.
                    * 노스틸 정책을 사용하면 디스크에 이전 상태의 페이지가 저장되어 있고, 로그엔 최신 변경 사항이 저장돼 있기 때문에 리두 로그만 사용해 상태를 복구할 수 있다.

                * 포스 정책은 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시한다. 노포스 정책은 일부 페이지가 디스크로 플러시되지 않았더라도 트랜잭션 커밋을 허용한다.
                    * 더티페이지를 포스한다는 것은 커밋 전에 디스크로 플러시한다는 것이다.
                    * 노포스 정책 사용 시 플러시 시점을 늦추면 더 많은 변경 사항을 버퍼링할 수 있다. 하지만 페이지를 더 오랫동안 캐시해야 하므로 더 큰 페이지 캐시가 필요할 수 있다.
                    * 포스 정책 사용 시 트랜잭션에서 수정한 페이지는 커밋 전 플러시되기 때문에 장애 복구 시 트랜잭션의 커밋 결과를 재구성하지 않아도 된다.
        
        * ### ARIES
            * ARIES는 스틸/노포스 정책 기반의 복구 알고리즘이다.
                * 빠른 복구를 위해 물리적 redo 로그를 사용하고, 일반 작업의 동시성을 높이기 위해 논리적 undo를 사용한다.
            
            * 장애 발생 후 데이터베이스 시스템을 재시작하면 복구는 다음 세 단계로 진행된다.
                1. 분석 단계 : 페이지 캐시에 저장된 더티 페이지와 장애 발생 당시 수행 중이던 트랜잭션을 파악한다. 더티 페이지에 대한 정보를 기반으로 redo 단계의 시작 지점을 결정한다. 트랜잭션 목록은 undo 단계에서 미완료된 트랜잭션을 롤백하는 데 사용한다.
                2. redo 단계 : 장애가 발생하기 전까지의 작업을 재수행하고 데이터베이스를 이전 상태로 복원한다. 불완전한 트랜잭션뿐만 아니라 커밋됐지만 결과가 디스크로 플러시되지 않은 트랜잭션을 롤백하기 위한 준비 단계이다.
                3. udno 단계 : 불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원한다. 모든 작업은 실제 수행 순서의 역순으로 롤백된다. 복구 중에도 장애가 발생할 수 있으므로 undo 작업도 로그에 기록해야 한다.
    
    * ## 동시성 제어
        * 동시성 제어의 분류
            * `낙관적 동시성 제어(OCC, Optimistic Concurrency Control)` : 여러 트랜잭션이 동시에 읽고 쓰는 것을 허용하고 결합된 여러 작업이 직렬화가 가능한지 여부를 결정한다.
                * 트랜잭션이 서로 간섭하지 않고 각자의 작업 내역을 유지할 수 있게 하고 커밋 전에 충돌이 발생할 수 있는지 확인한다. 충볼 살행 시 트랜잭션 하나를 중단한다.
            
            * `다중 버전 동시성 제어(MVCC, Multiversion Concurrency Control)` : 여러 버전의 레코드를 저장해 과거의 특정 타임스탬프의 데이터베이스의 일관성을 보장한다.

            * `비관적(또는 보수적) 동시성 제어(PCC, Pessimistc (also known as Conservative) Concurrency Control)` : PCC는 잠금 기반 방식과 무잠금 방식이 있으며, 두 방식은 공유 자원에 대한 관리 및 접근 방식이 다르다.
                * 잠금 기반 방식에서 각 트랜잭션은 다른 트랜잭션이 같은 레코드를 동시에 수정 및 접근할 수 없도록 레코드에 대한 잠금을 획득한다.
                * 무잠금 방식은 읽기와 쓰기 작업에 대한 목록을 유지하고 완료되지 않은 트랜잭션의 스케줄에 따라 다른 트랜잭션의 수행을 제한한다.

        * ### 직렬화 가능성
            * 트랜잭션은 데이터베이스의 상태를 읽고 쓰는 작업과 비즈니스 로직으로 구성된다.
                * 데이터베이스 관점에서 스케줄이란 트랜잭션을 수행하는 데 필요한 작업의 목록이다. 목록에 포함되지 않은 다른 작업은 부작용(데이터베이스 상태에 영향을 주지 않음)이 없다고 가정한다.
            
            * 완전한 스케줄은 관련 트랜잭션의 모든 작업을 포함한다.
            
            * 포함된 모든 트랜잭션이 교차하지 않고 완전히 독립적으로 수행될 수 있는 스케줄을 `직렬(serial) 스케줄`이라고 한다.
                * 직렬 스케줄의 모든 트랜잭션은 다음 트랜잭션이 시작하기 전에 수행이 완료된다.
                * 여러 단계로 구성된 트랜잭션이 교차 수행되는 것에 비해 직렬 수행은 매우 직관적이나, 항상 트랜잭션을 하나씩 실행하면 시스템의 처리량이 크게 제한되어 성능이 저하된다.
            
            * 트랜잭션을 동시에 수행하면서 직렬 스케줄의 정확성과 단순성을 유지하는 방법으로 `직렬화 가능한(serializable) 스케줄`이 있다.
                * 동일한 트랜잭션 집합에 대한 완전한 직렬 스케줄 중에서 동일한 스케줄이 있을 경우 해당 스케줄은 직렬화 가능하다고 한다.
        
        * ### 트랜잭션 격리
            * 격리 수준은 트랜잭션이 변경한 내용 중 어떤 부분이 언제 다른 트랜잭션에서 접근할 수 있는지 정의한다.
                * 격리 수준은 동시에 수행되는 트랜잭션이 고립된 정도와 수행 중에 발생할 수 있는 이상 현상(anomaly)이 발생할 수 있는지를 나타낸다.
        
        * ### 읽기와 쓰기 이상 현상
            * SQL 표준은 여러 트랜잭션이 동시 수행될 때 발생할 수 있는 읽기 이상 현상을 `더티 읽기(dirty read)`와 `반복 불가능 읽기(non-repeatable read)`, `팬텀 읽기(phantom read)`로 분류한다.
                * 더티 읽기는 아직 커밋되지 않은 다른 트랜잭션의 결과를 읽는 현상을 나타낸다.

                * 반복 불가능 읽기(퍼지 읽기, fuzzy read)는 트랜잭션이 동일한 로우를 두 번 쿼리했을 때 둘의 결과가 다른 현상을 나타낸다.

                * 트랜잭션에서 범위 쿼리를 수행하면 결과에 팬텀 레코드가 포함될 수 있다. 팬텀 읽기는 여러 로우를 두 번 쿼리했을 때 결과가 다른 현상을 나타낸다.

            * 쓰기 이상 현상은 `갱신 분실(lost update)`과 `더티 쓰기`, `쓰기 치우침(write skew)`으로 분류할 수 있다.
                * 갱신 분실은 여러 트랜잭션이 같은 값을 수정할 때 발생한다.

                * 더티 쓰기는 트랜잭션이 커밋되지 않은 값을 읽고 수정 및 커밋하는 현상을 나타낸다.

                * 개별 트랜잭션은 불변 조건을 충족하지만 동시 수행 시 조건이 위반되는 현상을 쓰기 치우침이라고 한다.
        
        * ### 격리 수준
            * 가장 낮은 격리 수준은 커밋 이전 읽기 수준이다. 이 수준에서 트랜잭션은 동시 수행 중인 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다.

            * 일부 이상 현상은 방지할 수 있다.

            * 가장 높은 격리 수준은 직렬화 가능 수준이다.
                * 직렬화 가능한 스케줄은 트랜잭션이 순차적으로 수행된 것처럼 어떤 순서에 따라 결과를 반환한다.
                * 동시성을 지원하지 않는 데이터베이스는 성능이 매우 떨어지므로 불변 조건을 위반하지 않고 트랜잭션을 동시에 수행할 수 있다면 트랜잭션의 수행 순서는 바뀔 수 있다.
            
            * 서로 의존성이 없는 트랜잭션은 완전히 독립적이기 때문에 임의의 순서로 수행해도 된다. 직렬화 가능성은 임의의 순서로 수행된 여러 작업에 대한 속성이다.
                * 수행 순서에 대한 특정 순서를 강제하거나 미리 정의하지 않는다.
                
            * 일부 데이터베이스는 스냅숏 격리 수준을 지원한다.
                * 스냅숏 격리 수준에서 각 트랜잭션은 시작 당시의 다른 트랜잭션이 커밋한 내용을 확인할 수 있다.
                * 트랜잭션은 데이터의 스냅숏을 생성하고 이에 대해 쿼리하며 트랜잭션 수행 중에는 스냅숏을 변경할 수 없다.
                * 트랜잭션에서 수정한 값이 수행 중에 변경되지 않은 경우에만 커밋될 수 있다. 변경됐다면 중단 후 롤백된다.
            
            * 두 개의 트랜잭션이 같은 값을 수정할 경우 한 개의 트랜잭션만이 커밋될 수 있다. 따라서 갱신 분실은 발생하지 않는다.
                * 먼저 커밋을 시도한 트랜잭션이 커밋되고 다른 트랜잭션은 중단된다. 실패한 프랜잭션은 값을 덮어쓰지 않고 작업을 재시도한다.
            
            * 스냅숏 격리 수준에서도 쓰기 치우침이 발생할 수 있다. 두 개의 트랜잭션이 각자의 스냅숏에서 값을 읽고 수정한 결과가 조건을 위반하지 않는다면 모두 커밋이 허용된다.