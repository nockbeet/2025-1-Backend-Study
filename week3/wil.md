2025-1 고급 백엔드 스터디 week3
================================

* # 2장 B-트리 개요
    * ## 이진 탐색 트리 (BST, Binary Search Tree)
        * `정렬된 인메모리 구조`로, 키-값 쌍 검색에 사용된다.
        * 키와 두 개의 자식 포인터가 저장된 여러 노드로 구성된다.
        * 탐색은 루트 노드에서 시작하고, 트리에는 단 한개의 루트 노드만 있을 수 있다.
        * BST의 각 노드는 탐색 공간을 왼쪽 서브트리와 오른쪽 서브트리로 분할한다.
        * 각 노드의 키는 왼쪽 서브트리의 모든 노드 키보다 크고, 오른쪽 서브트리의 모든 키보다 작다.
        * 탐색은 루트에서부터 시작하며, 대상 키를 찾으면 리프 레벨에 도달하기 전에 탐색이 끝날 수 있다.

        * ### 트리 밸런싱
            * 노드 삽입 작업에는 특정 패턴이 없으며, 삽입하는 값에 따라 트리가 불균형해질 수 있다.
            * `균형 트리`란 노드 개수가 N일 때 높이가 $\log_2 N$ 이고 두 서브트리의 높이 차이가 최대 1인 트리이다.
            * 균형트리의 각 노드에는 왼쪽과 오른쪽 2개의 노드 포인터가 있기 때문에 탐색 공간이 평균적으로 절반으로 줄어든다. 따라서 탐색 시간 복잡도는 O($\log_2 N$)이다.
            * 트리의 균형을 유지하는 방법 중 하나는 노드를 추가하거나 삭제한 후 트리를 회전하는 것이다. 노드 삽입으로 인해 트리의 균형이 깨진다면, 가운데 노드를 회전축 삼아 회전하면 해당 노드의 레벨이 한 단계 승급하고 부모 노드가 오른쪽 자식노드가 된다.
        
        * ### 디스크 기반 스토리지용 트리
            * BST는 높은 트리 유지 비용 때문에 디스크 기반 자료 구조로는 적합하지 않다.
            * BST를 디스크에서 제어하면 몇 가지 문제가 발생한다.
                * `지역성` 문제 : 노드는 키 순서에 따라 삽입되지 않기 때문에 새로운 노드와 부모 노드가 가까운 위치에 저장되지 않을 수 있다. 따라서 자식 포인터가 여러 다른 디스크 페이지를 가리킬 수 있다. 이 문제는 페이지 이진 트리를 사용해 일부 해결할 수 있다.
                * `트리의 높이` 문제 : 자식 포인터를 따라가는 비용과 밀접한 관계가 있다. `팬아웃`(fanout, 노드가 가질 수 있는 최대 자식 노드 개수)이 낮은 트리는 인메모리 자료 구조로는 유용하지만 노드의 크기가 작은 탓에 외부 스토리지 저장에는 비효율적이라는 한계가 있다.
            * 디스크 기반 BST의 구현은 지역성을 고려하지 않기 때문에 최악의 경우 비교 횟수만큼 디스크 탐색이 필요하다. 따라서 디스크 기반 트리를 선택할 때 지역성이 결여된 자료 구조는 피해야 한다.
            * 디스크 저장에 적합한 트리의 특성
                * 인접한 키의 지역성을 높이기 위한 높은 팬아웃
                * 트리 순회 중 디스크 탐색 횟수를 줄이기 위한 낮은 트리 높이
    
    * ## 디스크 기반 자료 구조
        * 메모리에 데이터 전부를 저장할 수 없을 때 주로 사용한다. 데이터 일부를 메모리에 캐시하고 나머지는 효율적으로 접근할 수 있는 형태로 디스크에 저장한다.

        * ### 하드 디스크 드라이브 (HDD)
            * 디스크에서는 탐색 작업이 랜덤 읽기 비용의 많은 부분을 차지한다. 디스크를 회전하고 읽기/쓰기용 헤드를 원하는 위치까지 물리적으로 옮겨야 하기 때문이다. 이후 연속된 바이트 읽기/쓰기(순차적 작업)는 상대적으로 비용이 낮다.
            * 디스크의 최소 전송 단위는 `섹터`이다. 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다.
            * 물리적 헤드 이동은 HDD 작업 중 가장 비용이 높은 작업이다. 따라서 디스크에서 연속된 메모리 섹터를 읽거나 쓰는 순차적 I/O를 극대화해야 한다.
        
        * ### 솔리드 스테이트 드라이브 (SSD)
            * 디스크와 달리 물리적으로 움직이는 부품이 없다. 회전하는 디스크도 없고, 이동시킬 헤드도 없다.
            * 일반적으로 SSD는 메모리 셀로 구성된다. 셀을 연결하면 스트링이 되고, 스트링의 배열이 페이지를 이룬다. 페이지가 모이면 블록이 된다.
            * 블록의 집합합은 플레인(plane), 플레인의 집합은 다이(die)라고 부르며, SSD는 한 개 이상의 다이로 구성된다.
            * 페이지는 읽고 쓸 수 있는 가장 작은 단위이고, 비어 있는 메모리 셀에만 쓸 수 있다. 삭제할 수 있는 가장 작은 단위는 여러 페이지로 구성된 블록이다. 블록 내 페이지는 순차적으로 쓴다.
            * `플래시 변환 레이어(FTL, Flash Translation Layer)` : 페이지 ID를 실제 위치와 매핑하고 비어 있거나 쓰여진 혹은 삭제된 페이지를 관리하는 플래시 메모리 컨트롤러이다.
                * FTL은 안전하게 지워도 되는 블록을 찾는 동안 가비지 컬렉션도 수행한다. 이미 사용 중인 페이지가 있을 경우, 해당 페이지를 다른 위치로 옮기고 페이지 ID 매핑도 알맞게 수정한다.
                * 사용하지 않는 블록은 재사용할 수 있도록 삭제한다.
            
            * HDD와 SSD는 개별 바이트 단위(데이터 블록 단위)가 아닌 메모리 청크 단위로 데이터를 참조한다. 따라서 대부분의 운영 체제에는 블록 디바이스 추상화 계층이 있다.
            * SSD는 HDD와 다르게 랜덤과 순차 I/O의 구분이 중요하지 않다. 둘 사이의 latency가 매우 작기 때문이다.
                * 하지만 prefetch와 연속된 페이지 읽기, 내부 정렬 처리 등으로 인한 차이는 존재한다.
        
        * ### 디스크 기반 자료 구조
            * 효율적인 디스크 기반 자료 구조 설계가 어려운 이유는 디스크 접근 비용뿐만 아니라, 가장 작은 작업 단위가 블록이라는 제약 때문이다.
                * 블록의 특정 위치를 참조하려면 블록 전체를 읽어야 한다.
            * 디스크 기반 자료 구조는 저장 매체의 구조를 고려해서 설계해야 하며, 디스크 접근 횟수를 최소화해야 한다. 내부 구조를 최적화하고 지역성을 높여 페이지를 넘나드는 포인터를 최소화해야 한다.
    
    * ## 유비쿼터스 B-트리
        * B-트리는 검색 항목을 빠르게 찾을 수 있는 계층형 자료 구조다. B-트리는 팬아웃이 높고 높이가 낮은 이진 탐색 트리 기반 트리이다.
        * B-트리는 키의 순서가 보장되는 자료 구조이다.
            * 노드 키를 기준으로 정렬해서 저장하기 때문에 이진 탐색과 같은 알고리즘을 사용해 특정 키를 찾을 수 있다. 따라서 B-트리 탐색의 시간 복잡도는 로그 시간이다.
            * B-트리의 노드에는 수십, 수백 개의 키를 저장하기 때문에 레벨별로 디스크를 한 번만 탐색하면 된다.

        * ### B-트리 계층
            * B-트리는 여러 노드로 구성된다. 노드는 논리적으로 다음 세 개의 계층으로 나눌 수 있다.
                * `루트 노드` : 트리의 최상위 노드로 부모 노드가 없다.
                * `내부 노드` : 루트와 리프 노드를 연결하는 모든 노드. 트리에는 일반적으로 한 개 이상의 내부 노드가 있다.
                * `리프 노드` : 자식 노드가 없는 트리의 최하위 계층 노드
            
            * B-트리는 페이지 기반 자료 구조(고정 크기 페이지 단위로 구성 및 탐색)이기 때문에 노드와 페이지가 같은 의미로 쓰이기도 한다.
            * 보유 가능한 노드 용량과 실제로 보유하고 있는 키의 개수의 비율을 `점유율(capacity)`이라고 한다.
            * B-트리에서 팬아웃은 중요한 속성이다.
                * 팬아웃이 높으면 트리의 구조를 유지하는 데 필요한 트리 구조 변경 비용을 낮출 수 있고 키와 포인터 같은 블록 또는 연속된 블록에 저장해 불필요한 탐색을 줄일 수 있다.
            
        * ### 구분 키
            * B-트리 노드에 저장된 키를 인덱스 엔트리, 구분 키, 또는 디바이더 셀(divider cell)이라고 부른다.
                * 각 키는 트리를 해당 키 범위의 서브트리로 분할한다.
                * 키는 정렬돼 있기 때문에 이진 검색에 사용할 수 있다.
            * 하향식으로 만들어지는 이진 트리와 반대로 B-트리는 `상향식`으로 트리를 구성한다.
            * 일부 변형 B-트리에서는 효율적인 범위 스캔을 위해 리프 노드에 형제 노드를 가리키는 포인터를 저장한다.
                * 이러면 부모를 거치지 않고 바로 형제 노드에 접근할 수 있다.
            * 리프 노드를 연결하는 이중 연결 리스트 형식의 포인터를 사용해 양방향으로 탐색할 수 있도록 B-트리를 구현하기도 한다.
            * B-트리는 나중에 삽입 및 업데이트될 노드의 공간을 미리 확보해둔다.
        
        * ### B-트리 탐색의 시간 복잡도
            * B-트리 탐색의 시간 복잡도는 `블록 전송 횟수`와 `비교 횟수`라는 두 가지 관점에서 계산할 수 있다.
                * 전송 횟수 관점 : 복잡도의 로그 밑은 N(각 노드별 키 개수)이다. 각 레벨에는 이전 레벨보다 K배 많은 노드가 있고, 자식 포인터를 따라가면 탐색 공간이 N의 비율로 감소한다.
                    * 특정 키를 찾기 위해서 최대 $\log_K M$개(M은 전체 노드 개수수)의 페이지에 접근해야 한다.
                * 비교 횟수 관점 : 각 노드 안에서 이진 탐색을 사용해 키를 찾기 때문에 복잡도의 로그 밑은 2이다.
                    * 비교할 때마다 탐색 공간이 절반으로 줄어들기 때문에 복잡도는 $\log_2 M$이다.
            * 일반적으로 교과서나 논문에서 B-트리의 탐색 시간 복잡도는 $\log M$이라고 설명한다.
                * 복잡도 계산에서 로그의 밑은 보통 무시한다.

        * ### B-트리 탐색 알고리즘
            * B-트리에서 특정 값을 찾으려면 루트에서 리프 레벨까지 순회해야 한다.
                * 탐색의 목적은 특정 키 또는 바로 앞 키를 찾는 것이다.
            * 탐색 알고리즘은 루트 노드에서부터 이진 검색을 수행한다.
                * 검색 키보다 큰 첫 번째 구분 키를 찾는다.
                * 인덱스 키는 인접한 두 개의 키 사이의 범위를 포함하는 서브트리를 가리킨다. 해당 서브트리를 찾고 리프 노드까지 포인터를 따라간다.
                * 이 탐색 과정을 반복하면서 대상 키를 찾아 반환하거나, 트리에 존재하지 않는 키의 경우 바로 앞의 값을 반환한다.
            * 낮은 레벨로 내려갈수록 검색 범위가 줄어든다.
            * 포인트 쿼리는 특정 키를 찾거나 찾는 데 실패했을 때 완료된다.
                * 범위 스캔은 키-값 쌍에서 시작해 범위의 끝에 도달하거나 더 이상 조건을 충족하지 않는 노드를 찾을 때까지 형제 노드 포인터를 따라간다.