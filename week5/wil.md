2025-1 고급 백엔드 스터디 week5
================================

* # 3장 파일 포맷
    * ## 파일 포맷 설계 원칙
        * 일반적으로 파일 포맷 설계 시 `주소 지정 방식(addressing)`부터 결정해야 한다.
            * 파일을 단일 블록 혹은 연속된 여러 블록으로 구성된 동일 크기의 페이지로 나눌 것인지 선택해야 한다.

        * 일반적으로 파일은 고정 크기의 `헤더`로 시작하면 끝부분에 고정 크기의 `트레일러`가 있을 수도 있다.
            * 여기엔 빠르게 접근하거나 파일의 나머지 부분을 디코딩하는 데 필요한 보조 정보가 들어간다.
            * 파일의 나머지 부분은 페이지로 나눠 저장한다.
        
        * 대부분의 데이터 스토어에는 테이블의 필드 수와 순서, 형식이 고정된 스키마가 있다.
            * 고정된 스키마를 사용하면 필드명을 반복적으로 저장하지 않고 각 위치를 활용해 디스크에 저장되는 데이터를 줄일 수 있다.
        
        * 파일 구조가 복잡해질 수록 더 많은 계층이 필요하다.
            * 필드는 기본형, 셀은 필드, 페이지는 셀, 섹션은 페이지, 리전은 섹션으로 구성된다.
            * 파일 포맷 설계 시 반드시 따라야 하는 규칙은 없다.
    
    * ## 페이지 구조
        * 데이터베이스 시스템은 데이터 레코드를 데이터 파일과 인덱스 파일에 저장한다.
            * 파일은 여러 파일시스템 블록을 합친 고정 크기의 페이지로 구성된다.
        
        * ex) 디스트 상의 B-트리 노드는 구조적 관점에서 키와 데이터 레코드 쌍을 저장하는 리프 노드, 키와 다른 노드를 가리키는 포인터를 저장하는 비 리프 노드로 나뉜다.
            * B-트리 노드는 단일 페이지 또는 연결된 여러 페이지로 구성된다. 즉, B-트리에서 맥락상 노드와 페이지의 의미는 같다.

    * ## 슬롯 페이지
        * 가변 길이 레코드 저장 시 삭제된 레코드의 공간을 회수하는 공간 관리 문제가 발생한다.
            * 길이가 m인 레코드가 저장된 위치에 길이가 n인 레코드를 저장할 때 m == n이 아니라면 이 공간을 최대한 활용하고자 정확히 길이가 m - n인 또 다른 레코드가 필요하다.
        
        * 페이지를 여러 개의 고정 길이 세그먼트로 분할하면 가변 길이 레코드를 저장할 수 있다.
            * 여전히 공간 낭비가 존재할 수 있다.
        
        * 페이지 포맷은 다음 조건을 충족해야 한다.
            * 최소한의 오버헤드로 가변 길이 레코드 저장
            * 삭제된 레코드의 메모리 회수
            * 페이지의 레코드를 정확한 위치와 상관없이 참조
        
        * 슬롯 페이지 또는 슬롯 디렉토리를 사용하면 가변 길이 자료형을 효율적으로 저장할 수 있다.
            * 페이지는 슬롯 또는 셀의 집합이다.
                * 페이지 내 독립적인 영역에 포인터와 셀을 분리해서 저장한다. 레코드의 논리적 순서는 셀을 가리키는 포인터의 순서로 제어할 수 있다.
                * 레코드 삭제 시 해당 포인터를 삭제하거나 null로 설정한다.
        
        * 슬롯 페이지에는 페이지와 셀에 대한 중요한 정보를 저장하는 고정 길이의 헤더가 있다.
            * 셀에는 키와 포인터, 레코드 등 임의의 데이터를 저장할 수 있으며 셀마다 크기는 다를 수 있다.
            * 슬롯 페이지는 다음 조건을 모두 충족한다.
                * `오버헤드 최소화` : 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드이다.
                * `공간 회수` : 단편화 제거 및 페이지 재구성을 통해 공간을 회수할 수 있다.
                * `동적 레이아웃` : 슬롯은 ID를 통해 페이지 외부에서 접근하기 때문에 정확한 위치는 페이지 내부에서만 필요하다.
    
    * ## 셀 구조
        * 플래그와 열거형, 기본형을 사용해 셀 레이아웃을 설계할 수 있다.
        * 셀은 키 셀과 키-값 셀로 나눌 수 있다.
            * 키 셀에는 구분 키와 인접한 두 키 사이의 페이지를 가리키는 포인터가, 키-값 셀에는 키와 해당 데이터 레코드가 들어간다.
        
        * 같은 페이지의 셀은 모두 형식이 같다고 가정한다.
            * 즉, 한 페이지 내의 모든 셀은 키 셀 혹은 키-값 셀이다.
        
        * 키 셀의 구성 요소
            * 셀 종류(페이지 메타데이터로부터 알아낼 수 있음)
            * 키 길이
            * 셀이 가리키는 자식 페이지의 ID
            * 키 바이트 수
        
        * 키-값 셀의 구성 요소
            * 셀 종류(페이지 메타데이터로부터 알아낼 수 있음)
            * 키 길이
            * 값 길이
            * 키 바이트
            * 데이터 레코드 바이트
        
        * 키-값 셀은 자식 페이지 ID 대신 실제 데이터를 저장한다.
            * 오프셋과 페이지 ID의 구분
                * 고정 크기의 페이지는 페이지 캐시가 관리하므로, 페이지 ID를 통해 룩업 테이블에서 오프셋을 참조할 수 있다.
                * 셀 오프셋은 페이지 내부에서 시작 오프셋으로부터 상대적인 위치를 나타낸다.
    
    * ## 셀 병합으로 슬롯 페이지 구성
        * 페이지의 셀은 오른쪽 끝에 추가하고, 셀 오프셋/포인터는 왼쪽에 추가한다.
            * 키는 삽입 순서대로 추가하고, 셀 오프셋 포인터는 키 순서대로 저장하여 논리적 순서를 유지한다. 이 방식은 셀을 삽입 또는 업데이트, 삭제해도 다른 셀을 재배치하지 않아도 된다.
    
    * ## 가변 길이 데이터 관리
        * 페이지 레코드 삭제 시 실제로 셀을 지우고 할당 해제된 공간으로 다른 셀을 옮길 필요는 없다.
            * 삭제된 셀이라고 표시하고 메모리에 저장된 사용 가능 목록에 회수된 메모리 크기와 해당 위치를 가리키는 포인터를 업데이트하는 방법도 존재한다.
            * 사용 가능 목록에는 사용할 수 있는 세그먼트의 크기와 위치가 저장된다. 새로운 셀을 삽입 전 이 목록에서 적합한 세그먼트가 있는지 확인한다.
        
        * 세그먼트는 다음 두 가지 전략에 따라 선택할 수 있다.
            * `최초 적합(First fit)` : 첫 번째로 찾은 적합한 세그먼트를 선택한다. 남은 공간이 또 다른 셀을 저장해 크기가 작을 수 있기 때문에 오버헤드가 발생할 수 있다.
            * `최적 적합(Best fit)` : 레코드를 저장할 수 있는 가장 작은 세그먼트를 선택한다.
        
        * 새로운 셀을 저장할 수 있는 연속된 공간이 없을 경우
            * 단편화된 부분의 집합 크기가 충분할 경우, 모든 셀을 읽고 재배치해 페이지의 단편화를 제거하면 새로운 셀을 연속된 공간에 저장할 수 있다.
            * 단편화를 제거해도 공간이 부족하다면 오버플로우 페이지를 생성해야 한다.
    
    * ## 버전 관리
        * 데이터베이스 시스템 개발 시 기능 추가, 버그 수정, 성능 개선 등을 포함하는 지속적인 업데이트를 제공하게 된다. 이 과정에서 바이너리 파일의 구조가 변경될 수 있다.
        * 다양한 파일 버전 관리 규칙이 존재한다.
            * 파일명의 접두사에 버전을 기록
            * 버전 정보를 개별 파일에 기록
            * 인덱스 파일 헤더에 버전 명시
                * 이 경우 헤더의 버전 정보는 반드시 모든 버전에서 읽을 수 있는 형식으로 인코딩해야 한다.
    
    * ## 체크섬
        * 디스크에 저장된 파일은 소프트웨어 버그와 하드웨어 장애 등으로 손상될 수 있는데, 이런 상황을 사전에 파악하고 손상된 데이터가 다른 서브시스템에 전파되는 것을 방지하기 위해 체크섬과 CRC(Cyclic Redundancy Check)를 사용한다.

        * 체크섬은 보장성이 매우 낮으면 다중 비트 오류를 감지할 수 없다.
            * 대부분 XOR과 패리티 검사(parity check) 또는 합(summation)을 사용한다.
        * CRC는 버스트 오류(다수의 연속된 비트가 손상된 상황)를 감지할 수 있다.
            * 일반적으로 룩업 테이블과 다항식의 나눗셈을 사용한다.